bl_info = {
    'name': 'CRT Tools',
    'category': 'Import-Export',
    'author': 'bvpav',
    'version': (0, 0, 1),
    'blender': (4, 3, 2),
    'description': 'Export and import CRT triangle C++ header files',
}

import re
import textwrap

import bpy
from bpy_extras.io_utils import ExportHelper, ImportHelper, axis_conversion
from bpy.types import Operator
from bpy.props import StringProperty
from mathutils import Vector


_blender_to_rh_conversion = axis_conversion(from_forward='-Y', from_up='Z', to_forward='Z', to_up='Y').to_4x4()
_rh_to_blender_conversion = axis_conversion(from_forward='Z', from_up='Y', to_forward='-Y', to_up='Z').to_4x4()


def _object_name_to_snake_case(name: str) -> str:
    return ''.join(c.lower() if c.isalpha() else '_' for c in name if c.isalpha()).rstrip('_')


def _get_triangle_world_vert_coords_rh(object: bpy.types.Object) -> list[list[Vector]]:
    if object.type != 'MESH':
        raise ValueError(f"{object!r} type must be 'MESH', got {object.type!r}")
    
    mesh = object.data
    
    triangles = []
    for triangle in mesh.loop_triangles:
        vert_coords = [_blender_to_rh_conversion @ object.matrix_world @ mesh.vertices[i].co for i in triangle.vertices]
        triangles.append(vert_coords)
    return triangles


def _create_mesh_from_triangles(triangles: list[list[Vector]], name: str) -> bpy.types.Object:
    """Create a Blender mesh object from triangle data."""
    # Create vertices and faces from triangles
    vertices = []
    faces = []
    vertex_index = 0
    
    for triangle in triangles:
        face = []
        for vert in triangle:
            # Convert coordinates back to Blender coordinate system
            blender_coord = _rh_to_blender_conversion @ vert
            vertices.append(blender_coord)
            face.append(vertex_index)
            vertex_index += 1
        faces.append(face)
    
    # Create mesh
    mesh = bpy.data.meshes.new(name)
    mesh.from_pydata(vertices, [], faces)
    mesh.update()
    
    # Create object
    obj = bpy.data.objects.new(name, mesh)
    bpy.context.collection.objects.link(obj)
    
    # Select and make active
    bpy.context.view_layer.objects.active = obj
    obj.select_set(True)
    
    return obj


def _cpp_format_float(value: float) -> str:
    value_str = str(value)
    value_str = value_str.rstrip('0')
    shortest_value_str = value_str.lstrip('.')
    if shortest_value_str != '.':
        value_str = shortest_value_str
    return f'{value_str}f'


def _cpp_format_vector(vector: Vector) -> str:
    return f'{{{_cpp_format_float(vector.x)}, {_cpp_format_float(vector.y)}, {_cpp_format_float(vector.z)}}}'


def _cpp_format_triangle(triangle: list[Vector]) -> str:
    if len(triangle) != 3:
        raise ValueError(f'Triangle must have 3 vertices, got {len(triangle)}')
    return f'{{ {_cpp_format_vector(triangle[0])}, {_cpp_format_vector(triangle[1])}, {_cpp_format_vector(triangle[2])} }}'


def _cpp_format_triangle_initializer_args(triangles: list[list[Vector]]) -> str:
    return ',\n'.join(map(_cpp_format_triangle, triangles))


def _cpp_format_header(triangles: list[list[Vector]], namespace_name: str) -> str:
    initializer_args = _cpp_format_triangle_initializer_args(triangles)
    return f'''#pragma once

// This file was generated by the {bl_info['name']} Blender addon ({__name__}) v{'.'.join(map(str, bl_info['version']))}.

#include <array>

#include "crt_triangle.h"

namespace {namespace_name} {{

const std::array<crt::Triangle, {len(triangles)}> triangles{{{{\n{textwrap.indent(initializer_args, '    ')}\n}}}};

}}
'''


def _cpp_parse_header(filepath: str) -> tuple[str, list[list[Vector]]]:
    """Parse C++ header file and extract namespace and triangles."""
    with open(filepath, 'r') as f:
        content = f.read()
    
    # Find namespace
    namespace_match = re.search(r'namespace\s+(\w+)\s*{', content)
    namespace_name = namespace_match.group(1) if namespace_match else 'imported'
    
    # Find triangle array using the specified regex pattern
    triangle_array_match = re.search(r'^const std::array<crt::Triangle, \d+> triangles\{\{(.+?)\}\};', content, re.MULTILINE | re.DOTALL)
    if not triangle_array_match:
        raise ValueError('No triangle array found in file matching the expected pattern')
    
    triangle_data = triangle_array_match.group(1)
    
    # Parse individual triangles
    triangles = []
    triangle_pattern = r'\{\s*\{([^}]+)\},\s*\{([^}]+)\},\s*\{([^}]+)\}\s*\}'
    
    for match in re.finditer(triangle_pattern, triangle_data):
        triangle = []
        for i in range(3):
            coords_str = match.group(i + 1)
            coords = [float(x.strip().rstrip('f')) for x in coords_str.split(',')]
            triangle.append(Vector(coords))
        triangles.append(triangle)
    
    return namespace_name, triangles


class ExportTriangleCppHeader(Operator, ExportHelper):
    """Write a CRT triangle C++ header file."""

    bl_idname = 'export_scene.crt_triangle_cpp_header'
    bl_label = 'Export CRT Triangle C++ Header File'

    filename_ext = '.h'

    filter_glob: StringProperty(
        default='*.h',
        options={'HIDDEN'},
    )

    @classmethod
    def poll(cls, context):
        return context.active_object is not None and context.active_object.type == 'MESH'

    def execute(self, context):
        vert_coords = _get_triangle_world_vert_coords_rh(context.active_object)
        with open(self.filepath, 'w') as f:
            f.write(_cpp_format_header(vert_coords, _object_name_to_snake_case(context.active_object.name)))
        return {'FINISHED'}


class ImportTriangleCppHeader(Operator, ImportHelper):
    """Load a CRT triangle C++ header file."""

    bl_idname = 'import_scene.crt_triangle_cpp_header'
    bl_label = 'Import CRT Triangle C++ Header File'

    filename_ext = '.h'

    filter_glob: StringProperty(
        default='*.h',
        options={'HIDDEN'},
    )

    def execute(self, context):
        try:
            namespace_name, triangles = _cpp_parse_header(self.filepath)
            if not triangles:
                self.report({'ERROR'}, 'No triangles found in file')
                return {'CANCELLED'}
            
            _create_mesh_from_triangles(triangles, namespace_name)
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}


def menu_func_export(self, context):
    self.layout.operator(ExportTriangleCppHeader.bl_idname, text='CRT Triangle C++ Header File (.h)')


def menu_func_import(self, context):
    self.layout.operator(ImportTriangleCppHeader.bl_idname, text='CRT Triangle C++ Header File (.h)')


classes = (
    ExportTriangleCppHeader,
    ImportTriangleCppHeader,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.TOPBAR_MT_file_export.append(menu_func_export)
    bpy.types.TOPBAR_MT_file_import.append(menu_func_import)


def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func_export)
    bpy.types.TOPBAR_MT_file_import.remove(menu_func_import)


if __name__ == '__main__':
    register()